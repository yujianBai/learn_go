go 天然支持并发


goroutine:其实是以一种协程
    协程：Coroutine
    1, 轻量级的线程
    2,     非抢占式多任务处理，由协程主动交出控制权
        （线程在任何时候都会被操作系统切换，线程是抢占式多任务处理， 控制权不再自己在操作系统，）

    3, 编译器/解释器/虚拟机层面的多任务
    4, 多个协程可能在一个或者多个线程上运行

    为啥协程轻量级，线程比较重？
        我理解这里，协程是非抢占多任务处理，有可能随时被cpu中断，需要保护现场，

        而，协程的控制权在协程自己， 任务是否中断是在于自己的控制,只需控制切换的几个点就行（这几个点是啥？我也不知道）
            ，无需保护现场，无需更多资源。


python 中的协程：
    使用yield 关键字实现协程
    python3.5 加入了async def 对协程的原生支持



goroutine的定义：
    1， 任何函数只需要加上go就能送给调度器运行
    2， 不需要在定义时区分是否异步函数
    3， 调度器在合适的点进行切换
    4,  使用-race 来检测数据访问冲突

goroutine可能切换的点：
    1， I/O， select
    2,  channel
    3,  等待所
    4， 函数调用
    5， runtime.Gosched()
    以上只是参考， 不能保证切换， 不能保证在其它地方不切换